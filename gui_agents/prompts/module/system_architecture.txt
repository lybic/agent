GUI-Agent Architecture and Workflow
1. System Overview
1.1 Core Components
Controller: Central controller responsible for state management and decision triggering
Manager: Task planner responsible for task decomposition and re-planning
Worker: Executor with three specialized roles:
   1. Technician: Uses system terminal to complete tasks
   2. Operator: Executes GUI interface operations
   3. Analyst: Provides analytical support
Evaluator: Quality inspector responsible for execution effectiveness evaluation
Hardware: Hardware interface responsible for actual operation execution
1.2 Global State Definitions
{
 "TaskStatus": ["created", "pending", "on_hold", "fulfilled", "rejected"],
 "SubtaskStatus": ["ready", "pending", "stale", "fulfilled", "rejected"],
 "ExecStatus": ["executed", "timeout", "blocked", "error"],
 "GateDecision": ["gate_done", "gate_fail", "gate_supplement", "gate_continue"],
 "GateTrigger": ["PERIODIC_CHECK", "WORKER_STALE", "WORKER_SUCCESS"],
 "controller_situation": ["INIT", "GET_ACTION", "SET_ACTION", "QUALITY_CHECK", "REPLAN", "SUPPLEMENT", "FINAL_CHECK", "DONE"],
}
State Descriptions:
TaskStatus: Overall task status
SubtaskStatus: Subtask status
ExecStatus: Command execution status
GateDecision: Quality check decision result
GateTrigger: Quality check trigger condition
controller_situation: Controller situation status
2. System Startup and Initialization
2.1 Startup Check
Initialize system state TaskStatus = pending
Check task status:
If TaskStatus = fulfilled or TaskStatus = rejected → Enter end state
Otherwise enter core scheduling loop
3. Core Scheduling Loop
3.1 State Flow Description

** GET_ACTION Generate specific operation instructions
Executing Component: Worker (Technician/Operator/Analyst)
GET_ACTION → Worker execution → Result judgment
├── success → current_situation = QUALITY_CHECK
├── CANNOT_EXECUTE → current_situation = REPLAN  
├── STALE_PROGRESS → current_situation = QUALITY_CHECK
└── generate action → current_situation = SEND_ACTION
└── supplement → current_situation = SUPPLEMENT

** SEND_ACTION Execute specific operations
Executing Component: Hardware
SEND_ACTION → Hardware execution → Get screenshot → Update history → current_situation = GET_ACTION

** QUALITY_CHECK Quality assessment of execution effectiveness
Executing Component: Evaluator
Core Functions: Visual comparison, progress analysis, efficiency evaluation
QUALITY_CHECK → Evaluator assessment → GateDecision judgment
├── gate_done → Check subtask status
│   ├── More subtasks exist → Switch to next subtask → current_situation = GET_ACTION
│   └── No more subtasks → current_situation=FINAL_CHECK
├── gate_fail → current_situation = REPLAN
├── gate_continue → current_situation = SEND_ACTION  
└── gate_supplement → current_situation = SUPPLEMENT

** REPLAN Re-plan tasks
Executing Component: Manager
REPLAN → Manager re-planning → Generate new subtasks → Assign Workers → current_situation = GET_ACTION
Processing Strategies:
   Light adjustment: Modify current subtask parameters
   Medium adjustment: Reorder subtasks
   Heavy adjustment: Complete task re-decomposition

** SUPPLEMENT Supplement external materials
Executing Component: Manager
SUPPLEMENT → Manager calls external tools → Generate supplementary materials → Record materials → current_situation = REPLAN
External Tools: web search, RAG, etc.

** FINAL_CHECK Final verification of task completion status
Executing Component: Evaluator
Trigger Condition: Final verification after all subtasks are marked as complete
FINAL_CHECK → Evaluator final assessment → Result judgment
├── Verification passed → TaskStatus = fulfilled → System ends
├── Issues found → current_situation = REPLAN → Continue execution
└── Cannot fix → TaskStatus = rejected → System ends
Verification Content:
   Whether overall objectives are achieved
   Whether all necessary steps are completed
   Whether final state meets expectations
   Whether there are omissions or errors

4. Worker Professional Division
4.1 Technician
Applicable Scenarios: Tasks requiring system-level operations
Working Method: Complete tasks through terminal commands
Typical Tasks:
File system operations
System configuration modifications
Program installation and deployment
Script execution
4.2 Operator
Applicable Scenarios: Tasks requiring GUI interface interaction
Working Method: Simulate user interface operations
Typical Tasks:
Clicking buttons, menus
Filling forms
Drag and drop operations
Window management
4.3 Analyst
Applicable Scenarios: Tasks requiring data analysis and decision support
Working Method: Analyze current state, provide recommendations
Typical Tasks:
Question analysis
Format modification

5. Monitoring and Trigger Mechanisms
5.1 Quality Check Trigger Mechanism
GateTrigger Types:
PERIODIC_CHECK: Periodic check
   5 steps have passed since last inspection
   Regular verification of execution progress
WORKER_STALE: Worker stagnation check
   Same consecutive action more than 3 times
   Single subtask execution actions exceed 15 times
WORKER_SUCCESS: Worker successful completion
   Worker reports task completion
   Need to verify completion quality
5.2 Task Termination Conditions
TaskStatus = rejected conditions:
   Manager planning attempts > 10 times
   Manager re-planning consecutive failures 3 times
   current_step > N steps (timeout termination)
   Encountering irreparable system errors
TaskStatus = fulfilled conditions:
   All subtask status = fulfilled
   FINAL_CHECK verification passed
   Expected target state achieved
5.3 ExecStatus Handling
   executed: Normal execution completion → Continue process
   timeout: Execution timeout → Retry or re-plan
   blocked: Execution blocked → Analyze blocking cause, adjust strategy
   error: Execution error → Error handling, may need re-planning
6. State Monitoring Mechanism
6.1 SubtaskStatus Management
   ready: Ready for execution, waiting
   pending: Currently executing
   stale: Execution stagnated, needs intervention
   fulfilled: Successfully completed
   rejected: Execution failed
6.2 State Transition Monitoring
   System continuously monitors state changes at all levels:
   TaskStatus changes trigger global process adjustments
   SubtaskStatus changes affect current execution strategy
   ExecStatus changes determine immediate response measures
   All state changes are recorded in execution history
7. System Workflow Overview
System Startup → Task Initialization → Main Loop (loop through all subtasks)
   ↓
REPLAN (Manager plans all subtasks)
   ↓
GET_ACTION (Worker generates instructions)
   ↓  
SEND_ACTION (Hardware executes)
   ↓
QUALITY_CHECK (Evaluator quality inspection)
   ↓
Branch based on GateDecision:
├── gate_continue → Continue SEND_ACTION
├── gate_done → Check more subtasks or FINAL_CHECK  
├── gate_fail → REPLAN re-planning
└── gate_supplement → SUPPLEMENT supplement materials
   ↓
Finally converges to FINAL_CHECK → System ends

Incremental Clarification Policy (for unreadable UI details)
- When the current screenshot does not make critical UI regions legible (e.g., spreadsheet headers, cell ranges, table columns), the Manager MUST first plan an Operator subtask to adjust zoom/viewport to clarify and batch-memorize the required labels/ranges, and set MANAGER_COMPLETE=false. Subsequent computation/input subtasks should be planned only after the clarified screenshot is available.